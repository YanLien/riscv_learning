# 函数调用规范与栈

1. 请阐述RISC-V的函数调用规范。
2. 在函数调用过程中，如果函数传递的参数大于8个，该如何传递参数？
3. 假设函数调用关系为main()→func1()→func2()，请画出RSIC-V体系结构下函数栈的布局。
4. 请画出RISC-V体系结构下函数调用过程中的入栈和出栈过程。
5. 请阐述在RISC-V体系结构下如何通过FP回溯整个栈。

## 函数调用规范

函数调用规范(calling convention)是用来描述父/子函数是如何编译和链接的，特别是父函数和子函数之间调用关系的约定，如栈的布局、参数的传递等。

| 名称 | ABI别名 | 描述 | 调用过程中是否需要保存 |
| ---- | ----- | ----- | -------- |
| ×0 | zero | 内容一直为0的寄存器 | 否 |
| x1 | ra | 保存返回地址 | 否 |
| x2 | sp | 保存栈指针 | 是 |
| x3 | gp | 保存全局指针 | 否 |
| x4 | tp | 保存线程指针 | 否 |
| x5~x7 | t0~t2 | 临时寄存器 | 否 |
| x8~x9 | s0~s1 | 被调用者需要保存的寄存器 | 是 |
| x10~x17 | a0~a7 | 传递子程序的参数和结果 |否 |
| x18~x27 | s2~s11 | 被调用者需要保存的寄存器 | 是 |
| x28~x31 | t3~t6 | 临时寄存器 | 否 |

函数调用规范如下：

+ 函数的前8个参数使用a0～a7寄存器来传递。如果函数参数大于8个，前8个参数使用寄存器来传递，后面的参数使用栈来传递。
+ 如果传递的参数小于寄存器宽度（64位）​，那么先按符号扩展到32位，再按符号扩展到64位。如果传递的参数为寄存器宽度的2倍（128位）​，那么将使用一对寄存器来传递该参数。
+ 函数的返回参数保存在a0和a1寄存器中。函数的返回地址保存在ra寄存器中。
+ 如果子函数里使用s0～s11寄存器，那么子函数在使用前需要把这些寄存器的内容保存到栈中，使用完之后再从栈中将内容恢复到这些寄存器里。
+ 栈向下增长（向较低的地址）​，sp寄存器在进入函数时要对齐到16字节的边界上。传递给栈的第一个参数位于sp寄存器的偏移量0处，后续的参数存储则在相应的较高地址处。
+ 如果GCC使用-fno-omit-frame-pointer编译选项，那么编译器将使用s0寄存器作为栈帧指针(Frame Pointer,FP)。

```
高地址 +-----------------+ <--- 调用者函数的 SP（在调用前）
      |     参数 2       |
      +-----------------+
      |     参数 1       |
      +-----------------+
      |   返回地址       |
      +-----------------+ <--- 调用者函数的 FP (也是旧FP)
      |  保存的FP (旧FP) | <--- 当前函数的 FP **指向这里！(栈帧底部)**
      +-----------------+
      |  保存的寄存器    |
      +-----------------+
      |  局部变量 1      |
      +-----------------+
      |  局部变量 2      |
      +-----------------+
      |     ...         |
      +-----------------+ <--- 当前函数的 SP **(栈顶)**
低地址 +-----------------+
```

## 入栈和出栈

栈(stack)是一种后进先出的数据存储结构，栈的起始地址称为栈底，栈从高地址往低地址延伸到的某个点称为栈顶。栈需要一个指针来指向栈最新分配的地址，即指向栈顶。这个指针是栈指针(SP)。作用如下。
+ 保存临时存储的数据，如局部变量等。
+ 在函数调用过程中，如果传递的参数少于或等于8个，使用a0～a7通用寄存器来传递。当参数多于8个时，多余的参数需要使用栈来传递。

在RISC-V体系结构中，每个栈帧的大小至少为16字节。sp寄存器指向栈顶，并且必须按16字节对齐。从栈底开始的16字节用来存储函数的返回地址和FP的值（假设GCC使用-fno-omit-frame-pointer编译选项）。其中，s_ra用来存储函数返回地址，s_fp用来存储FP的值。

![alt text](/doc/img/chapter4/img_1.png)

## RISC-V的栈布局

两种情况

+ 不使用FP。若在GCC中使用`-fomit-frame-pointer`编译选项，可以不使用FP，在函数入栈和出栈时减少访问内存的指令，从而提高程序性能。
+ 使用FP。在GCC中通过`-fno-omit-frame-pointer`编译选项使用FP，目的是在调试过程中可以方便地计算每个栈的大小并回溯栈帧。


情况一：不使用FP的栈布局

不使用FP情况下，RISC-V中函数栈布局的关键点如下：
+ 所有的函数调用栈都是从高地址向低地址扩展。
+ SP永远指向栈顶（栈的最低地址）​。
+ 如果调用了子函数，函数的返回地址需要保存到栈里，即s_ra位置。
+ 栈的大小为16字节的倍数。
+ 函数返回时需要先把返回地址从栈（s_ra位置处）中恢复到ra寄存器，然后执行RET指令。

情况二：使用FP的栈布局

使用FP的情况下，RISC-V体系结构中函数栈布局的关键点如下：
+ 所有的函数调用栈都会组成一个单链表。
+ 每个栈使用两个地址来构成这个链表，这两个地址都是64位宽的，并且它们都位于栈底。
    + s_fp的值指向上一个栈帧（父函数的栈帧）的栈底。
    + s_ra保存当前函数的返回地址，也就是父函数调用该函数时下一条指令的地址。
+ 函数返回时，RISC-V处理器先把返回地址从栈的s_ra位置处载入当前ra寄存器，然后执行RET指令。
+ 最末端函数（也称为叶子函数，即该函数内部不再调用任何其他函数。）不用保存ra寄存器，因为最末端函数的ra寄存器不会被破坏。

情况三：栈回溯

标准栈回溯的核心原理：

两大主流原理

1. Frame Pointer 链表法

    ```
    栈帧结构（以RISC-V为例）：

    函数C栈帧:
    +------------------+  
    |   返回地址 (ra)   |  <-- FP - 8
    +------------------+
    |   上级FP         |  <-- FP - 16  (指向函数B的FP位置)
    +------------------+  <-- 当前FP
    |   局部变量        |
    +------------------+

    函数B栈帧:
    +------------------+
    |   返回地址        |
    +------------------+
    |   上级FP         |  <-- 指向函数A的FP
    +------------------+  <-- 函数B的FP
    |   ...            |
    ```

    核心思想：

    + FP形成单向链表，每个FP指向上一级函数的FP位置
    + 返回地址总在FP的固定偏移处（由ABI规定）
    + 沿着FP链表向上遍历 = 栈回溯

2. DWARF展开信息法 (现代标准)

    原理：编译器在二进制文件中嵌入栈展开元数据表

    ```
    ELF文件结构:
    [代码段]
    [数据段]
    [.eh_frame段]  <-- 存储每个函数的栈布局信息
    - 函数A: PC范围, FP偏移规则, RA位置...
    - 函数B: PC范围, FP偏移规则, RA位置...
    ```
    元数据示例（伪代码）：
    ```
    函数地址: 0x1000-0x1100
    规则:
    - CFA = SP + 128          (规范帧地址)
    - RA = *(CFA - 8)         (返回地址位置)
    - 上级FP = *(CFA - 16)    (如何找上一级)
    ```
    回溯流程：
    ```
    1. 获取当前PC
    2. 查DWARF表 → 找到对应函数的展开规则
    3. 根据规则计算: 返回地址在哪? 上一级栈帧在哪?
    4. 跳到上一级，重复步骤2-3
    ```

补充：**尾调用优化**是一种编译器技术，它识别出尾调用的情况，并对其进行优化。优化后的行为是：

+ 不把它当作一次真正的“调用”，而是当作一次“跳转”。
+ 复用当前函数的栈帧，而不是为被调用函数创建新的栈帧。
+ 在跳转到被调用函数之前，根据需要设置好参数。
+ 直接使用 j（跳转）指令或 jalr（跳转并链接寄存器）指令，而不是 call（它实际上是 auipc + jalr 的伪指令）来跳转到目标函数。