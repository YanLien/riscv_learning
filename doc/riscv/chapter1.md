# 基本知识

## RISC-V指令集

RV32I是RISC-V指令集中固定不变的最小指令集。RISC-V针对64位处理器的最小指令集是RV64I，表示64位基础整型指令集。
RISC-V提供了一个稳定的指令集组合，称为RV32G/RV64G。其中，G表示IMAFD，实现基础整型指令集、整型乘法和除法扩展指令集、原子操作指令集以及单精度浮点数和双精度浮点数扩展指令集。

RISC-V扩展指令集

| 扩展指令集 | 说明 |
| ------ | ---- |
| F | 单精度浮点数扩展指令集 | 
| D | 双精度浮点数扩展指令集 |
| Q | 4倍精度浮点数扩展指令集 |
| M | 整型乘法和除法扩展指令集 |
| C | 压缩指令集 |
| A | 原子操作指令集 |
| B | 位操作指令集 |
| E | 为嵌入式设计的整型指令集 |
| H | 虚拟化扩展指令集 |
| K | 密码运算扩展指令集 |
| V | 可伸缩矢量扩展指令集|
| P | 打包SIMD扩展指令集|
| J | 动态翻译语言扩展指令集 |
| T | 事务内存指令集 |
| N | 用户态中断指令集 |

## RISC-V体系结构的基本概念

1.**执行环境接口(Execution Environment Interface, EEI)**：包括程序的初始状态、CPU的类型和数量、支持的S(Supervisor)模式、内存和I/O区域的可访问性与属性、在每个CPU上执行指令的行为以及任何异常（包括中断、系统调用）的处理等。常见的RISC-V执行环境接口包括Linux应用程序二进制接口(Application Binary Interface,ABI)以及RISC-V管理员二进制接口(Supervisor Binary Interface, SBI)。本质上，EEI就是"软件和环境之间的协议" - 规定了谁提供什么服务，怎么使用这些服务。

2.**模拟器**：在主机上模拟RISC-V的用户模式以及特权模式的执行环境。

3.**硬件线程(Hart)**：一个处理器执行线程，在执行环境中自主获取和执行RISC-V指令资源的硬件单元，类似于x86体系结构中的超线程(Hyper-Threading, HT)以及ARMv8体系结构中的处理机(processing element)。SMT（Surface Mount Technology, 表面安装技术）让同一个处理器内核上的多个线程同步执行并共享处理器的执行资源。假设一个RISC-V处理器实现了超线程技术，那么一个处理器内核就有多个硬件线程，不过目前商用的RISC-V处理器还没有实现超线程技术。

## 特权级别(privilege level)

包括RISC-V处理器提供的3种模式。

**机器模式（M模式）​：以M模式运行的代码通常在本质上是可信的，因为它具有对机器实现的全部访问权限，常用于管理RISC-V上的安全执行环境。通常在M模式下运行SBI固件，为操作系统提供服务。**

**特权模式（S模式）​：通常用来运行操作系统的内核，为应用程序提供服务。**

**用户模式（U模式）​：特权级别最低，通常用来运行应用程序。**

使能了虚拟化扩展后，新增如下特权模式。

**HS模式：把原有的S模式扩展为HS模式，用来运行虚拟化管理程序。**

**VS模式：通常用来运行虚拟机操作系统内核。**

**VU模式：通常用来运行虚拟机操作系统中的应用程序。**

## SBI服务

在没有使能虚拟化扩展的RISC-V系统

![](/doc/img/chapter1/img_1.png)

使能了虚拟化扩展的RISC-V系统

![](/doc/img/chapter1/img_2.png)

```
物理硬件
   ↑
【主机世界】
M-mode: SBI固件 ← 提供底层硬件服务
   ↓
HS-mode: Hypervisor(虚拟化管理程序)
   ↓
U-mode: 主机应用程序 ← 通过系统调用访问Hypervisor

【虚拟化世界】  
M-mode: SBI固件 ← 为Hypervisor提供服务
   ↓
HS-mode: Hypervisor ← 为虚拟机提供SBI服务  
   ↓
S-mode: 虚拟机OS
   ↓
U-mode: 虚拟机应用程序
```

## RISC-V寄存器

### 通用寄存器

64位/32位的RISC-V体系结构提供32个64位/32位的整型通用寄存器，分别是x0～x31寄存器。对于支持浮点扩展的RISC-V架构，32位和64位版本都提供32个浮点寄存器f0~f31，寄存器宽度分别对应32位和64位。

+ **x0寄存器的别名为zero。寄存器的内容全是0，可以用作源寄存器，也可以用作目标寄存器。**
+ **x1寄存器的别名为ra——链接寄存器，用于保存函数返回地址。**
+ **x2寄存器的别名为sp——栈指针寄存器，指向栈的地址。**
+ **x3寄存器的别名为gp——全局寄存器，用于链接器松弛优化。**
+ **x4寄存器的别名为tp——线程寄存器，通常在操作系统中用于保存指向进程控制块-`task_struct`数据结构的指针。**
+ **x5~x7以及x28~x31寄存器为临时寄存器，它们的别名分别是t0~t6。**
+ **x8~x9以及x18~x27寄存器的别名分别是s0~s11。如果函数调用过程中要使用这些寄存器，需要先保存到栈里。另外，s0寄存器可以用作栈帧指针(Frame Pointer, FP)。**
+ **x10~x17寄存器的别名分别为a0~a7，用于在调用函数时传递参数和返回结果。**

![RISC-V整型通用寄存器](/doc/img/chapter1/img_3.png)

### 系统寄存器

**详细内容参考：doc/riscv-privileged.pdf#Control and Status Registers (CSRs)**

系统控制和状态寄存器(Control and Status Register, CSR)

通过`CSR`指令（如`CSRRW`指令）访问系统寄存器

CSR指令编码中预留了12位编码空间用来索引系统寄存器，即指令编码中的`Bit[31:20]`​。

![](/doc/img/chapter1/img_4.png)

RISC-V体系结构对12位CSR编码空间做了约定。其中，`Bit[11:10]`用来表示系统寄存器的读写属性，`0b11`表示只读，其余表示可读可写。`Bit[9:8]`表示允许访问该系统寄存器的处理器模式，`0b00`表示U模式，`0b01`表示S模式，`0b10`表示HS/VS模式，`0b11`表示M模式。剩余的位用作寄存器的索引。使用CSR地址的最高位对默认的访问权限进行编码，简化了硬件中的错误检查流程，并提供了更大的CSR编码空间，但限制了CSR到地址空间的映射。

下面的访问行为会触发非法指令异常：
+ 访问不存在或者没有实现的系统寄存器
+ 尝试写入只具有只读属性的系统寄存器
+ 在低级别的处理器模式下访问高级别的处理器模式的系统寄存器，

#### M模式的系统寄存器

| 地址/CSR编码 | CSR名称 | 属性 | 说明 |
| ---- | ------ | ---- | ---- |
| `0xF11` | `mvendorid` | MRO | 机器厂商ID寄存器 |
| `0xF12` | `marchid` | MRO | 体系结构ID寄存器 |
| `0xF13` | `mimpid` | MRO | 实现编号寄存器 |
| `0xF14` | `mhartid` | MRO | 处理器硬件线程ID寄存器 |
| `0xF15` | `mconfigptr` | MRO | 配置数据结构寄存器 |
| `0x300` | `mstatus` | MRW | M模式下的处理器状态寄存器 |
| `0x301` | `misa` | MRW | M模式下的指令集体系结构和扩展寄存器 |
| `0x302` | `medeleg` | MRW | M模式下的异常委托寄存器 |
| `0x303` | `mideleg` | MRW | M模式下的中断委托寄存器 |
| `0x304` | `mie` | MRW | M模式下的中断使能寄存器 |
| `0x305` | `mtvec` | MRW | M模式下的异常向量入口地址寄存器 |
| `0x306` | `mcounteren` | MRW | M模式下的技术使能寄存器 |
| `0x340` | `mscratch` | MRW | M模式下的用于异常处理的临时寄存器 |
| `0x341` | `mepc` | MRW | M模式下的异常模式PC寄存器 |
| `0x342` | `mcause` | MRW | M模式下的异常原因寄存器 |
| `0x343` | `mtval` | MRW | M模式下的异常向量寄存器 |
| `0x344` | `mip` | MRW | M模式下的中断待定寄存器 |
| `0x34A` | `mtinst` | MRW | M模式下的陷入指令(用于虚拟化) |
| `0x34B` | `mtval2` | MRW | M模式下的异常向量寄存器(用于虚拟化) |

+ **`misa`寄存器**用来表示处理器支持的指令集体系结构和扩展
   + Extensions：表示处理器支持的扩展，如表1.8所示。
      + | 位 | 名称 | 说明 |
        | --- | --- | --- |
        | 0 | A | 原子操作扩展 |
        | 1 | B | 位操作扩展 |
        | 2 | C | 压缩指令扩展 |
        | 3 | D | 双精度浮点数扩展 |
        | 4 | E | RV32E指令集 |
        | 5 | F | 单精度浮点数扩展 |
        | 6 | G | 保留 |
        | 7 | H | 虚拟化扩展 |
        | 8 | I | RV32I/RV64I/RV128I基础指令集 |
        | 9 | J | 动态翻译语言扩展 |
        | 10 | K | 保留 |
        | 11 | L | 保留 |
        | 12 | M | 整数乘/除扩展 |
        | 13 | N | 用户中断扩展 |
        | 14 | O | 保留 |
        | 15 | P | SIMD扩展 |
        | 16 | Q | 4倍精度浮点数扩展 |
        | 17 | R | 保留 |
        | 18 | S | 支持S模式 |
        | 19 | T | 保留 |
        | 20 | U | 支持U模式 |
        | 21 | V | 可伸缩矢量扩展 |
        | 22 | W | 保留 |
        | 23 | X | 非标准扩展 |
        | 24 | Y | 保留 |
        | 25 | Z | 保留 |
   + MXL：表示M模式下寄存器的长度。
      + 1：表示32位
      + 2：表示64位
      + 3：表示128位
+ **`mvendorid`寄存器**是一个32位只读寄存器，遵循JEDEC制造商ID规范
+ **`marchid`寄存器**用于返回处理器体系结构ID，该ID由RISC-V基金会统一分配。
+ **`mimpid`寄存器**用于返回处理器的实现版本ID
+ **`mhartid`寄存器**用于返回处理器硬件线程ID。多核处理器中硬件线程的ID不一定是连续编号的，但至少有一个硬件线程的ID为0，同时需保证运行环境中硬件线程的ID互不相同。
+ **`mstatus`寄存器**表示M模式下的处理器状态
   ![mstatus寄存器](/doc/img/chapter1/img_7.png)
   | 字段 | 位段 | 说明 |
   | ---- | ---- | ---- |
   | SIE | Bit[1] | 中断使能位，用来使能和关闭S模式下所有的中断 |
   | MIE | Bit[3] | 中断使能位，用来使用和关闭M模式下所有的中断 |
   | SPIE | Bit[5] | 中断使能保存位，当一个异常陷入S模式时，SIE的值保存到SPIE中，SIE设置为0。当调用SPIE指令返回时，从SPIE中恢复SIE的值，然后SPIE设置为1 |
   | UBE | Bit[6] | 用来控制U模式下加载和存储指令访问内存的大小端模式；0表示小端模式，1表示大端模式。 |
   | MPIE | Bit[7] | 中断使能保存位，当一个异常陷入M模式时，MIE的值保存到MPIE中，MIE设置为0。当调用MRET指令返回时，从MPIE中恢复MIE的值，然后MPIE设置为1。 |
   | SPP | Bit[8] | 表示陷入S模式之前CPU的处理模式；0表示从U模式陷入到S模式，1表示在S模式触发的异常 |
   | VS | Bit[10:9] | 用来使能可伸缩矢量扩展 |
   | MPP | Bit[12:11] | 表示陷入M模式之前CPU的处理模式；0表示从U模式陷入到M模式，1表示从S模式陷入到M模式，2表示从M模式触发的异常 |
   | FS | Bit[14:13] | 用来使能浮点数单元 |
   | XS | Bit[16:15] | 用来使能U模式下扩展的其他状态 |
   | MPRV | Bit[17] | 用来修改有效特权模式；0表示加载和存储指令按照当前的处理器模式进行地址转换与内存保护，1表示加载和存储指令按照MPP字段中存储的处理器模式的权限进行内存保护和检查 |
   | SUM | Bit[18] | 指定在S模式下是否允许访问U模式的内存；0表示在S模式下访问U模式下的内存时会触发异常，1表示在S模式下可以访问U模式下的内存 |
   | MXR | Bit[19] | 指定访问内存的权限；0表示可以加载只读页面，1可以加载可读和可执行的页面|
   | TVM | Bit[20] | 支持拦截S模式下的虚拟内存管理操作；0表示在S模式下可以正常访问satp寄存器或者执行SFENCE.VMA/SINVAL.VMA指令，1表示在S模式下访问satp寄存器或者执行SFENCE.VMA/SINVAL.VMA指令会触发非法指令异常 |
   | TW | Bit[21] | 支持拦截WFI指令；0代表WFI指令可以在低权限模式下执行，1表示如果WFI指令以任何低特权模式执行，并且它没有在特定实现中约定的有限时间内完成，就会触发非法指令异常 |
   | TSR | Bit[22] | 支持拦截SRET指令；0表示在S模式下正常执行SRET指令，1表示在S模式下执行SRET指令会触发非法指令异常 |
   | UXL | Bit[33:32] | 用来表示U模式下寄存器的长度 |
   | SXL | Bit[35:34] | 用来表示S模式下寄存器的长度 |
   | SBE | Bit[36] | 用来控制S模式下加载和内存访问的大小端模式；0表示小端模式，1表示大端模式 |
   | MBE | Bit[37] | 用来控制M模式下加载和内存访问的大小端模式；0表示小端模式，1表示大端模式 |
   | SD | Bit[63] | 用来表示VS，FS以及XS中任意一个字段已经设置 |
+ **medeleg寄存器**用于把异常委托到S模式下处理
+ **mideleg寄存器**用于把中断委托到S模式下处理
+ **mie寄存器**用来使能和关闭M模式下的中断
+ **mtval寄存器**当处理器陷入M模式时，mtval寄存器记录发生异常的虚拟地址
+ **mcounteren寄存器**是一个32位寄存器，用来使能S模式或者U模式下的硬件性能监测和计数寄存器，字段的含义如下。
   ![](/doc/img/chapter1/img_8.png)
   + CY字段：使能S模式或者U模式下的cycle系统寄存器。
   + TM字段：使能S模式或者U模式下的time系统寄存器。
   + IR字段：使能S模式或者U模式下的instret系统寄存器。
   + HPM3～HPM31字段：使能S模式或者U模式下的hpmcounter3～hpmcounter31系统寄存器。
+ **`mscratch`寄存器**是一个专门给M模式使用的临时寄存器，当处理器运行在S模式或者U模式下时，它用来保存M模式中上下文数据结构的指针。
+ 当处理器陷入M模式时，会将中断或遇到异常的指令的虚拟地址写入`mepc`寄存器中。
+ **`mcause`寄存器**是M模式下的异常原因寄存器。
+ **`mip`寄存器**用来表示哪些中断处于待定状态。

#### S模式的系统寄存器

| 地址/CSR编码 | CSR名称 | 属性 | 说明 |
| ---- | ------ | ---- | ---- |
| `0x100` | `sstatus` | SRW | S模式下的处理器状态寄存器 |
| `0x104` | `sie` | SRW | S模式下的中断使能寄存器 |
| `0x105` | `stvec` | SRW | S模式下的异常向量表入口地址寄存器 |
| `0x106` | `scounteren` | SRW | S模式下的计数使能寄存器 |
| `0x10A` | `senvcfg` | SRW | S模式下的环境配置寄存器 |
| `0x140` | `sscratch` | SRW | S模式下的用于异常处理的临时寄存器 |
| `0x141` | `sepc` | SRW | S模式下的异常模式程序计数器(Program Counter, PC)寄存器 |
| `0x142` | `scause` | SRW | S模式下的异常原因寄存器 |
| `0x143` | `stval` | SRW | S模式下的异常向量寄存器 |
| `0x144` | `sip` | SRW | S模式下的中断待定寄存器 |
| `0x180` | `satp` | SRW | S模式下的地址转换与保护寄存器 |
| `0x5A8` | `scontext` | SRW | S模式下的上下文寄存器（用于调试）|

+ **`sstatus`寄存器**表示S模式下的处理器状态

   `WPRI`表示这些字段是保留的，软件应该忽略从这些字段读取的值，并且在向同一寄存器的其他字段写入值时，应该保留这些字段中保存的值。通常，为了向前兼容，硬件会将这些字段设为只读的零值。

   ![sstatus寄存器](/doc/img/chapter1/img_5.png)

   |字段|位段|说明|
   |------|------|------|
   |`SIE`| Bit[1]|中断使能位，用来使能和关闭S模式中所有的中断｜
   |`SPIE`|Bit[5]|中断使能保存位，当一个异常陷入S模式时，`SIE`的值保存到`SPIE`中，`SIE`设置为0，当调用`SRET`指令返回时，从SPIE中恢复到SIE，然后SPIE设置为1|
   |`UBE`|Bit[6]|用来控制U模式下加载和存储指令访问内存的大小端模式，其中0代表小端模式，1代表大端模式|
   |`SPP`|Bit[8]|表示陷入S模式之前CPU的处理模式，其中0代表从U模式陷入到S模式，1代表从S模式触发的异常|
   |`VS`|Bit[10:9]|用来使能`RVV`|
   |`FS`|Bit[14:13]|用来使能浮点数单元|
   |`XS`|Bit[16:15]|用来使能其他U模式下扩展的状态|
   |`SUM`|Bit[18]|用来设置在S模式下能否允许访问U模式下的内存，0代表在S模式下访问U模式的内存时触发异常，1代表S模式下可以访问U模式的内存|
   |`MXR`|Bit[19]|用来设置访问内存的权限，0代表可以加载只读页面，1代表可以加载可读和可执行的页面|
   |`UXL`|Bit[33:32]|用来表示U模式的寄存器长度，通常是一个只读字段，并且U模式下寄存器的长度等于S模式下寄存器的长度|
   |`SD`|Bit[63]|用来表示`VS`，`FS`以及`XS`中任意一个字段已经设置|

   注：

   `SIE`和`SPIE`的工作机制
   1. 异常发生时的自动操作
   ```
   假设用户程序运行时发生异常：
   异常前： SIE = 1 (中断开启)
   异常后： 硬件自动执行：
         SPIE ← SIE  (保存当前状态: SPIE = 1)
         SIE ← 0     (禁用中断: SIE = 0)
   ```
   2. 异常返回时的自动操作
   ```
   执行 sret 指令时：
         SIE ← SPIE   (恢复中断状态: SIE = 1)
         SPIE ← 1     (重置 SPIE = 1)
   ```

   在 RISC-V 的内存管理中：

   + 用户页面：页表项中 U=1 的页面，通常只允许用户模式访问
   + 内核页面：页表项中 U=0 的页面，只允许 Supervisor 模式访问

   默认行为：Supervisor 模式不能访问用户页面（U=1的页面）
   SUM=1 时：Supervisor 模式可以访问用户页面

+ **`sie`寄存器**用来使能和关闭S模式下的中断
+ **`stvec`寄存器**用来在S模式下配置异常向量表入口地址和异常访问模式
+ **`scounteren`寄存器**是一个32位寄存器，用来使能U模式下的硬件性能监测和计数寄存器，

   ![alt text](/doc/img/chapter1/img_6.png)

   各字段的含义如下：
   + `CY`字段：使能U模式下的`cycle`系统寄存器。
   + `TM`字段：使能U模式下的`time`系统寄存器。
   + `IR`字段：使能U模式下的`instret`系统寄存器。
   + `HPM3`~`HPM31`字段：使能U模式下的`hpmcounter3`~`hpmcounter31`系统寄存器。

+ **`sscratch`寄存器**是一个专门给S模式使用的临时寄存器，当处理器运行在U模式下时，它用来保存S模式下的进程控制块的指针。
+ 当处理器陷入S模式时，会把中断现场或触发异常时的指令对应的虚拟地址写入**`sepc`寄存器**中。
+ **`scause`寄存器**用于保存S模式下的异常原因。
+ 当处理器陷入S模式时，**`stval`寄存器**会记录发生异常的虚拟地址。
+ **`sip`寄存器**用来表示哪些中断处于待定(pending)状态。
+ **`satp`寄存器**用于地址转换。

#### U模式的系统寄存器

| 地址/CSR编码 | CSR名称 | 属性 | 说明 |
| ---- | ------ | ---- | ---- |
| `0x001` | `fflags` | URW | U模式下的浮点数累计异常(accrued exception) |
| `0x002` | `frm` | URW | U模式下的浮点数动态舍入模式(dynamic rounding mode) |
| `0x003` | `fcsr` | URW | U模式下的浮点数控制和状态寄存器 |
| `0xC00` | `cycle` | URO | U模式下的读取时钟周期，映射到`RDCYCLE`伪指令 |
| `0xC01` | `time` | URO | U模式下的读取time系统寄存器的值，映射到`RDTIME`伪指令 |
| `0xC02` | `instret` | URO | U模式下的执行指令数目，映射到`RDINSTRET`伪指令 |
| `0xC03`~`0xC1F` | `hpmcounter3`~`hpmcounter31` | URO | U模式下的性能监测寄存器 |

`RDCYCLE`伪指令读取`cycle`系统寄存器的值，返回处理器内核执行的时钟周期数。注意，它返回的是物理处理器内核（而不是处理器硬件线程）的时钟周期数。`RDCYCLE`伪指令的主要作用是进行性能监控和调优。

`RDTIME`伪指令读取`time`系统寄存器的值，获取系统的实际时间。系统每次启动时读取CMOS上的RTC（Real Time Clock，实时时钟）计数，时钟中断时更新该计数。

`RDINSTRET`伪指令读取`instret`系统寄存器的值，返回处理器执行线程已经执行的指令数量。

`hpmcounter3`～`hpmcounter31`为29个用于系统性能监测的寄存器，这些计数器的计数记录平台的事件，并通过额外的特权寄存器进行配置。

`RDCYCLE`、`RDTIME`以及`RDINSTRET`伪指令在某些处理器上是通过`SBI固件`进行软件模拟实现的。

# 参考资料

+ [https://github.com/riscv-non-isa/riscv-sbi-doc](https://github.com/riscv-non-isa/riscv-sbi-doc)