# 内联汇编

通过 `asm!`、`naked_asm!` 和 `global_asm!` 宏提供对内联汇编的支持。它可用于将手写汇编代码嵌入到编译器生成的汇编输出中。

## 语法

以下语法指定了可以传递给 `asm!`、`global_asm!` 和 `naked_asm!` 宏的参数。


## 作用域

内联汇编可以通过三种方式之一使用。

使用 `asm!` 宏时,汇编代码在函数作用域内发出,并集成到编译器生成的函数汇编代码中。这些汇编代码必须遵守严格的规则以避免未定义行为。注意,在某些情况下,编译器可能会选择将汇编代码作为单独的函数发出并生成对它的调用。

``` rust
unsafe { core::arch::asm!("/* {} */", in(reg) 0); }
```

使用 `naked_asm!` 宏时,汇编代码在函数作用域内发出,并构成函数的完整汇编代码。`naked_asm!` 宏只允许在裸函数(naked functions)中使用。

``` rust
core::arch::naked_asm!("/* {} */", const 0);
```

使用 `global_asm!` 宏时,汇编代码在全局作用域内发出,位于函数外部。这可以用于使用汇编代码手写完整的函数,并且通常提供更大的自由度来使用任意寄存器和汇编器指令。

``` rust
core::arch::global_asm!("/* {} */", const 0);
```

## 模板字符串参数

汇编模板使用与[格式化字符串](https://doc.rust-lang.org/alloc/fmt/index.html#syntax)相同的语法(即占位符由花括号指定)。

相应的参数按顺序、按索引或按名称访问。

``` rust
let x: i64;
let y: i64;
let z: i64;
// 这种写法
unsafe { core::arch::asm!("mov {}, {}", out(reg) x, in(reg) 5); }
// ... 这种写法
unsafe { core::arch::asm!("mov {0}, {1}", out(reg) y, in(reg) 5); }
// ... 以及这种写法
unsafe { core::arch::asm!("mov {out}, {in}", out = out(reg) z, in = in(reg) 5); }
// 都具有相同的行为
assert_eq!(x, y);
assert_eq!(y, z);
```
> 注意：
>
> + `reg` 是一个标识符，代表一个寄存器类别
> + 编译器的寄存器分配器会自动从该类别中选择一个可用的寄存器

但是,不支持隐式命名参数(由 [RFC #2795](https://github.com/rust-lang/rfcs/pull/2795) 引入)。

``` rust
let x = 5;
// 我们不能直接从作用域引用 `x`,我们需要像 `in(reg) x` 这样的操作数
unsafe { core::arch::asm!("/* {x} */"); } // 错误:没有名为 x 的参数
```

一个 asm! 调用可以有一个或多个模板字符串参数;具有多个模板字符串参数的 asm! 会被视为所有字符串之间用 \n 连接。预期的用法是每个模板字符串参数对应一行汇编代码。

``` rust
let x: i64;
let y: i64;
// 我们可以分离多个字符串,就像它们写在一起一样
unsafe { core::arch::asm!("mov eax, 5", "mov ecx, eax", out("rax") x, out("rcx") y); }
assert_eq!(x, y);
```

所有模板字符串参数必须出现在任何其他参数之前。

``` rust
let x = 5;
// 模板字符串需要在 asm! 调用中首先出现
unsafe { core::arch::asm!("/* {x} */", x = const 5, "ud2"); } // 错误:意外的标记
```

+ 所有模板字符串必须作为前几个参数出现
+ 不能在操作数参数之后再添加模板字符串
+ 正确写法应该是：`asm!("/* {x} */", "ud2", x = const 5)`

与格式化字符串一样,**位置参数**必须出现在命名参数和显式寄存器操作数之前。

``` rust
// 命名操作数需要在位置操作数之后
unsafe { core::arch::asm!("/* {x} {} */", x = const 5, in(reg) 5); }
// 错误:位置参数不能跟在命名参数或显式寄存器参数之后
```
参数顺序规则

+ 位置参数（如 in(reg) 5）
+ 命名参数（如 x = const 5）
+ 显式寄存器操作数（如 in("eax") 0）

``` rust
// 我们也不能将显式寄存器放在位置操作数之前
unsafe { core::arch::asm!("/* {} */", in("eax") 0, in(reg) 5); }
// 错误:位置参数不能跟在命名参数或显式寄存器参数之后
```

显式寄存器操作数不能被模板字符串中的占位符使用。

``` rust
// 显式寄存器操作数不会被替换,需要在字符串中显式使用 `eax`
unsafe { core::arch::asm!("/* {} */", in("eax") 5); }

```
所有其他命名和位置操作数必须在模板字符串中至少出现一次,否则会生成编译器错误。

``` rust
// 我们必须在格式字符串中命名所有操作数
unsafe { core::arch::asm!("", in(reg) 5, x = const 5); }
// 错误:多个未使用的 asm 参数
```

``` rust
let result: i64;

unsafe {
    core::arch::asm!(
        "mov ecx, 10",              // 显式寄存器 ecx，直接写名字
        "add {0}, ecx",             // {0} 是位置参数
        "add {output}, {val}",      // {output} 和 {val} 是命名参数
        out(reg) result,            // 位置参数 0
        in("ecx") 10,               // 显式寄存器，不能用 {} 引用
        output = inout(reg) result, // 命名参数
        val = const 5               // 命名参数
    );
}
```

确切的汇编代码语法是特定于目标平台的,并且对编译器来说是不透明的,除了操作数替换到模板字符串中以形成传递给汇编器的代码的方式。
目前,所有支持的目标平台都遵循 LLVM 内部汇编器使用的汇编代码语法,这通常对应于 GNU 汇编器(GAS)的语法。在 x86 上,默认使用 GAS 的 `.intel_syntax noprefix` 模式。在 ARM 上,使用 `.syntax unified` 模式。这些目标平台对汇编代码施加了额外的限制:任何汇编器状态(例如可以用`.section`更改的当前节)必须在 asm 字符串末尾恢复到其原始值。不符合 GAS 语法的汇编代码将导致特定于汇编器的行为。内联汇编使用的指令的进一步约束由指令支持(Directives Support)指示。

## 操作数类型

支持以下几种类型的操作数:

+ in(<reg>) <expr>
    + <reg> 可以引用寄存器类或显式寄存器。分配的寄存器名称会被替换到 asm 模板字符串中。
    + 在汇编代码开始时,分配的寄存器将包含 <expr> 的值。
    + 在汇编代码结束时,分配的寄存器必须包含相同的值(除非将 lateout 分配给同一寄存器)。
        ``` rust
        // `in` 可用于将值传递到内联汇编中...
        unsafe { core::arch::asm!("/* {} */", in(reg) 5); }
        ```
+ out(<reg>) <expr>
    + <reg> 可以引用寄存器类或显式寄存器。分配的寄存器名称会被替换到 asm 模板字符串中。
    + 在汇编代码开始时,分配的寄存器将包含未定义的值。
    + <expr> 必须是一个(可能未初始化的)位置表达式,在汇编代码结束时,分配的寄存器的内容会被写入该位置。
    + 可以指定下划线(_)来代替表达式,这将导致寄存器的内容在汇编代码结束时被丢弃(实际上充当破坏标记)。
        ``` rust
        let x: i64;
        // `out` 可用于将值传回 Rust
        unsafe { core::arch::asm!("/* {} */", out(reg) x); }
        ```
+ lateout(<reg>) <expr>
    + 与 out 相同,但寄存器分配器可以重用分配给 in 的寄存器。
    + 您应该只在读取所有输入之后才写入寄存器,否则可能会破坏输入。
        ``` rust
        let x: i64;
        // `lateout` 与 `out` 相同
        // 但编译器知道在我们覆盖它时,我们不关心任何输入的值
        unsafe { core::arch::asm!("mov {}, 5", lateout(reg) x); }
        assert_eq!(x, 5)
        ```
+ inout(<reg>) <expr>
    + <reg> 可以引用寄存器类或显式寄存器。分配的寄存器名称会被替换到 asm 模板字符串中。
    + 在汇编代码开始时,分配的寄存器将包含 <expr> 的值。
    + <expr> 必须是一个可变的已初始化位置表达式,在汇编代码结束时,分配的寄存器的内容会被写入该位置。
        ``` rust
        let mut x: i64 = 4;
        // `inout` 可用于在寄存器中修改值
        unsafe { core::arch::asm!("inc {}", inout(reg) x); }
        assert_eq!(x, 5);
        ```
+ inout(<reg>) <in expr> => <out expr>
    + 与 inout 相同,但寄存器的初始值取自 <in expr> 的值。
    + <out expr> 必须是一个(可能未初始化的)位置表达式,在汇编代码结束时,分配的寄存器的内容会被写入该位置。
    + 可以为 <out expr> 指定下划线(_)来代替表达式,这将导致寄存器的内容在汇编代码结束时被丢弃(实际上充当破坏标记)。
    + <in expr> 和 <out expr> 可以有不同的类型。
        ```rust
        let x: i64;
        // `inout` 也可以将值移动到不同的位置
        unsafe { core::arch::asm!("inc {}", inout(reg) 4u64=>x); }
        assert_eq!(x, 5);
        ```
+ inlateout(<reg>) <expr> / inlateout(<reg>) <in expr> => <out expr>
    + 与 inout 相同,但寄存器分配器可以重用分配给 in 的寄存器(如果编译器知道 in 与 inlateout 具有相同的初始值,就会发生这种情况)。
    + 您应该只在读取所有输入之后才写入寄存器,否则可能会破坏输入。
        ```rust
        let mut x: i64 = 4;
        // `inlateout` 是使用 `lateout` 的 `inout`
        unsafe { core::arch::asm!("inc {}", inlateout(reg) x); }
        assert_eq!(x, 5);
        ```
+ sym <path>
    + <path> 必须引用 fn 或 static。
    + 引用该项的修饰符号名称会被替换到 asm 模板字符串中。
    + 替换的字符串不包含任何修饰符(例如 GOT、PLT、重定位等)。
    + <path> 允许指向 #[thread_local] static,在这种情况下,汇编代码可以将符号与重定位(例如 @plt、@TPOFF)结合使用以从线程局部数据读取。
        ``` rust
        extern "C" fn foo() {
            println!("Hello from inline assembly")
        }
        // `sym` 可用于引用函数(即使它没有我们可以直接写入的外部名称)
        unsafe { core::arch::asm!("call {}", sym foo, clobber_abi("C")); }
        ```
+ const <expr>
    + <expr> 必须是整数常量表达式。该表达式遵循与内联 const 块相同的规则。
    + 表达式的类型可以是任何整数类型,但默认为 i32,就像整数字面量一样。
    + 表达式的值被格式化为字符串并直接替换到 asm 模板字符串中。
        ``` rust
        // 混洗 [0, 1, 2, 3] => [3, 2, 0, 1]
        const SHUFFLE: u8 = 0b01_00_10_11;
        let x: core::arch::x86_64::__m128 = unsafe { core::mem::transmute([0u32, 1u32, 2u32, 3u32]) };
        let y: core::arch::x86_64::__m128;
        // 将常量值传递给期望立即数的指令,如 `pshufd`
        unsafe {
            core::arch::asm!("pshufd {xmm}, {xmm}, {shuffle}",
                xmm = inlateout(xmm_reg) x=>y,
                shuffle = const SHUFFLE
            );
        }
        let y: [u32; 4] = unsafe { core::mem::transmute(y) };
        assert_eq!(y, [3, 2, 0, 1]);
        ```
+ label <block>
    + 块的地址会被替换到 asm 模板字符串中。汇编代码可以跳转到替换的地址。
    + 对于区分直接跳转和间接跳转的目标平台(例如启用了 cf-protection 的 x86-64),汇编代码不得间接跳转到替换的地址。
    + 执行完块后,asm! 表达式返回。
    + 块的类型必须是单元类型 unit 或 !(never)。
    + 块启动一个新的安全上下文;标签块中的不安全操作必须包装在内部 unsafe 块中,即使整个 asm! 表达式已经包装在 unsafe 中。
        ``` rust
        unsafe {
            core::arch::asm!("jmp {}", label {
                println!("Hello from inline assembly label");
            });
        }
        ```

操作数表达式从左到右求值,就像函数调用参数一样。在 asm! 执行之后,输出按从左到右的顺序写入。如果两个输出指向同一位置,这一点很重要:该位置将包含最右边输出的值。

``` rust
let mut y: i64;
// y 从第二个输出获取其值,而不是第一个
unsafe { core::arch::asm!("mov {}, 0", "mov {}, 1", out(reg) y, out(reg) y); }
assert_eq!(y, 1);
```

因为 naked_asm! 定义整个函数体,并且编译器无法发出任何额外的代码来处理操作数,所以它只能使用 sym 和 const 操作数。
因为 global_asm! 存在于函数之外,所以它只能使用 sym 和 const 操作数。

``` rust
// 不允许使用寄存器操作数,因为我们不在函数中
core::arch::global_asm!("", in(reg) 5);
// 错误:`in` 操作数不能与 `global_asm!` 一起使用
fn foo() {}

// 但是,`const` 和 `sym` 都是允许的
core::arch::global_asm!("/* {} {} */", const 0, sym foo);
RetryClaude can make mistakes. Please double-check responses.
```

1. in - 单向输入
``` rust
unsafe { core::arch::asm!("add {}, 5", in(reg) x); }
```

+ 作用：把 Rust 变量的值放入寄存器，供汇编代码使用
+ 流向：Rust → 寄存器 → 汇编代码读取
+ 汇编代码结束后，寄存器值被丢弃

2. out - 单向输出
``` rust
let x: i64;
unsafe { core::arch::asm!("mov {}, 5", out(reg) x); }
```
+ 作用：汇编代码写入寄存器，结果传回 Rust 变量
+ 流向：汇编代码写入 → 寄存器 → Rust 变量
+ 进入汇编时，寄存器值是未定义的

3. lateout - 延迟输出
``` rust
unsafe { core::arch::asm!("mov {}, 5", lateout(reg) x); }
```
+ 作用：和 out 一样，但告诉编译器"我会在读完所有输入后才写这个寄存器"
+ 优点：编译器可以把这个寄存器复用给 in 操作数，节省寄存器
+ 注意：必须先读完所有输入再写入

4. inout - 双向传递（同一变量）
``` rust
let mut x = 5;
unsafe { core::arch::asm!("inc {}", inout(reg) x); }
// x 现在是 6
```
+ 作用：同一个变量既作为输入又作为输出
+ 流向：Rust 变量 → 寄存器 → 汇编修改 → 写回同一变量

5. inout 分离版本 - 双向传递（不同变量）
``` rust
let x = 5;
let y: i64;
unsafe { core::arch::asm!("inc {}", inout(reg) x => y); }
// y 现在是 6，x 保持 5
```
作用：输入来自一个变量，输出到另一个变量
流向：x → 寄存器 → 汇编修改 → y

6. inlateout - 延迟双向传递 寄存器可以复用
``` rust
let mut x = 5;
unsafe { core::arch::asm!("inc {}", inlateout(reg) x); }
```
+ 作用：inout + lateout 的组合
+ 优点：可以复用寄存器，但必须先读完输入再写

> "延迟"的含义：
> 
> + 不是时间上的延迟
> + 而是写入操作发生在读取操作之后
> + 这让编译器可以优化寄存器分配

## 寄存器操作数

输入和输出操作数可以指定为显式寄存器或寄存器类别,寄存器分配器可以从中选择寄存器。显式寄存器指定为字符串字面量(例如 "eax"),而寄存器类别指定为标识符(例如 reg)。

``` rust
let mut y: i64;
// 我们可以同时命名 `reg`,或像 `eax` 这样的显式寄存器来获取
// 整数寄存器
unsafe { core::arch::asm!("mov eax, {:e}", in(reg) 5, lateout("eax") y); }
assert_eq!(y, 5);
```

请注意,显式寄存器将寄存器别名(例如 ARM 上的 r14 与 lr)和寄存器的较小视图(例如 eax 与 rax)视为与基础寄存器等效。
将同一显式寄存器用于两个输入操作数或两个输出操作数是编译时错误。

``` rust
// 我们不能两次命名 eax
unsafe { core::arch::asm!("", in("eax") 5, in("eax") 4); }
// 错误: 寄存器 `eax` 与寄存器 `eax` 冲突
// ... 即使使用不同的别名
unsafe { core::arch::asm!("", in("ax") 5, in("rax") 4); }
// 错误: 寄存器 `rax` 与寄存器 `ax` 冲突
```

此外,在输入操作数或输出操作数中使用重叠寄存器(例如 ARM VFP)也是编译时错误。

``` rust
// al 与 ax 重叠,所以我们不能同时命名它们。
unsafe { core::arch::asm!("", in("ax") 5, in("al") 4i8); }
// 错误: 寄存器 `al` 与寄存器 `ax` 冲突
```

只有以下类型可以作为内联汇编的操作数:

+ 整数(有符号和无符号)
+ 浮点数
+ 指针(仅瘦指针)
+ 函数指针
+ SIMD 向量(使用 #[repr(simd)] 定义并实现 Copy 的结构体)。这包括在 std::arch 中定义的架构特定向量类型,如 __m128(x86)或 int8x16_t(ARM)。

``` rust
extern "C" fn foo() {}

// 允许整数...
let y: i64 = 5;
unsafe { core::arch::asm!("/* {} */", in(reg) y); }

// 和指针...
let py = &raw const y;
unsafe { core::arch::asm!("/* {} */", in(reg) py); }

// 也允许浮点数...
let f = 1.0f32;
unsafe { core::arch::asm!("/* {} */", in(xmm_reg) f); }

// 甚至函数指针和 simd 向量。
let func: extern "C" fn() = foo;
unsafe { core::arch::asm!("/* {} */", in(reg) func); }

let z = unsafe { core::arch::x86_64::_mm_set_epi64x(1, 0) };
unsafe { core::arch::asm!("/* {} */", in(xmm_reg) z); }
```

``` rust
struct Foo;
let x: Foo = Foo;
// 不允许像结构体这样的复杂类型
unsafe { core::arch::asm!("/* {} */", in(reg) x); }
// 错误: 不能将类型 `Foo` 的值用于内联汇编
```

以下是当前支持的寄存器类别列表:

| 架构 | 寄存器类别 | 寄存器 | LLVM 约束代码 |
| ----------- | -------- | ------ | -------- | --------------- |
| RISC-V | reg | x1, x[5-7], x[9-15], x[16-31] (non-RV32E) | r |
| RISC-V | freg | f[0-31] | f |
| RISC-V | vreg | v[0-31] | Only clobbers |

> 注意
> 
> + 在 x86 上,我们将 reg_byte 与 reg 区别对待,因为编译器可以单独分配 al 和 ah,而 reg 保留整个寄存器。
> + 在 x86-64 上,高字节寄存器(例如 ah)在 reg_byte 寄存器类别中不可用。
> + 某些寄存器类别标记为"仅破坏",这意味着这些类别中的寄存器不能用于输入或输出,只能用于 `out(<explicit register>) _` 或 `lateout(<explicit register>) _` 形式的破坏。

每个寄存器类别对可以使用的值类型都有约束。这是必要的,因为将值加载到寄存器的方式取决于其类型。例如,在大端系统上,将 i32x4 和 i8x16 加载到 SIMD 寄存器可能会导致不同的寄存器内容,即使两个值的字节级内存表示相同。特定寄存器类别支持的类型可用性可能取决于当前启用的目标特性。

| 架构 | 寄存器类别 | 目标特性 | 允许的类型 |
| ------------ | ------------- | -------------- | ------------- |
| RISC-V32 | reg | None | i8, i16, i32, f32 |
| RISC-V64 | reg | None | i8, i16, i32, f32, i64, f64 |
| RISC-V | freg | f | f32 |
| RISC-V | freg | d	| f64 |
| RISC-V | vreg	| N/A | Only clobbers |

> 注意
> 
> 就上表而言,指针、函数指针和 isize/usize 被视为等效整数类型(根据目标为 i16/i32/i64)。

``` rust
let x = 5i32;
let y = -1i8;
let z = unsafe { core::arch::x86_64::_mm_set_epi64x(1, 0) };

// reg 对 `i32` 有效,`reg_byte` 对 `i8` 有效,xmm_reg 对 `__m128i` 有效
// 我们不能将 `tmm0` 用作输入或输出,但可以破坏它。
unsafe { core::arch::asm!("/* {} {} {} */", in(reg) x, in(reg_byte) y, in(xmm_reg) z, out("tmm0") _); }
let z = unsafe { core::arch::x86_64::_mm_set_epi64x(1, 0) };
// 我们不能将 `__m128i` 传递给 `reg` 输入
unsafe { core::arch::asm!("/* {} */", in(reg) z); }
// 错误: 类型 `__m128i` 不能与此寄存器类别一起使用
```

如果值的大小小于分配给它的寄存器,则该寄存器的高位对于输入将具有未定义的值,对于输出将被忽略。唯一的例外是 RISC-V 上的 freg 寄存器类别,其中 f32 值按照 RISC-V 架构的要求在 f64 中进行 NaN 装箱。

``` rust
let mut x: i64;
// 将 32 位值移动到 64 位值,糟糕。
#[allow(asm_sub_register)] // rustc 警告此行为
unsafe { core::arch::asm!("mov {}, {}", lateout(reg) x, in(reg) 4i32); }
// 高 32 位是不确定的
assert_eq!(x, 4); // 此断言不保证成功
assert_eq!(x & 0xFFFFFFFF, 4); // 但是,这个断言会成功
```

当为 `inout` 操作数指定单独的输入和输出表达式时,两个表达式必须具有相同的类型。唯一的例外是如果两个操作数都是指针或整数,在这种情况下它们只需要具有相同的大小。此限制存在是因为 LLVM 和 GCC 中的寄存器分配器有时无法处理具有不同类型的绑定操作数。

``` rust
// 指针和整数可以混合(只要它们大小相同)
let x: isize = 0;
let y: *mut ();
// 使用内联汇编魔法将 `isize` 转换为 `*mut ()`
unsafe { core::arch::asm!("/*{}*/", inout(reg) x=>y); }
assert!(y.is_null()); // 制造空指针的极其迂回的方法
let x: i32 = 0;
let y: f32;
// 但我们不能像这样将 `i32` 重新解释为 `f32`
unsafe { core::arch::asm!("/* {} */", inout(reg) x=>y); }
// 错误: asm inout 参数的类型不兼容
```

## 寄存器名称

某些寄存器有多个名称。编译器将这些名称视为与基础寄存器名称相同。以下是所有支持的寄存器别名列表:

| Architecture | Base register | Aliases |
| ------ | ------- | --------- |
| RISC-V | x0 | zero |
| RISC-V | x1 | ra |
| RISC-V | x2 | sp |
| RISC-V | x3 | gp |
| RISC-V | x4 | tp |
| RISC-V | x[5-7] | t[0-2] |
| RISC-V | x8 | fp, s0 |
| RISC-V | x9 | s1 |
| RISC-V | x[10-17] | a[0-7] |
| RISC-V | x[18-27] | s[2-11] |
| RISC-V | x[28-31] | t[3-6] |
| RISC-V | f[0-7] | ft[0-7] |
| RISC-V | f[8-9] | fs[0-1] |
| RISC-V | f[10-17] | fa[0-7] |
| RISC-V | f[18-27] | fs[2-11] |
| RISC-V | f[28-31] | ft[8-11] |

``` rust
let z = 0i64;
// rax 是 eax 和 ax 的别名
unsafe { core::arch::asm!("", in("rax") z); }
```

某些寄存器不能用于输入或输出操作数:

| Architecture | Unsupported register | Reason |
| ------------ | -------------------- | ------ |
| All | sp | 堆栈指针必须在汇编代码结束时或跳转到标签块之前恢复到其原始值。|
| All | x8(RISC-V) | 帧指针不能用作输入或输出。|
| All | x9(RISC-V) | LLVM 内部将其用作具有复杂堆栈帧的函数的"基指针"。|
| RISC-V | x0 | 这是一个常量零寄存器,不能被修改。|
| RISC-V | gp, tp | 这些寄存器是保留的,不能用作输入或输出。|

``` rust
// bp 是保留的
unsafe { core::arch::asm!("", in("bp") 5i32); }
// 错误: 无效的寄存器 `bp`: 帧指针不能用作内联汇编的操作数
```

帧指针和基指针寄存器为 LLVM 内部使用而保留。虽然 asm! 语句不能显式指定使用保留寄存器,但在某些情况下,LLVM 会为 reg 操作数分配这些保留寄存器之一。使用保留寄存器的汇编代码应该小心,因为 reg 操作数可能使用相同的寄存器。

## 模板修饰符

占位符可以通过在大括号中`:`后指定的修饰符进行增强。这些修饰符不影响寄存器分配,但会改变将操作数插入模板字符串时的格式化方式。

每个模板占位符只允许一个修饰符。

``` rust
// 我们不能同时指定 `r` 和 `e`。
unsafe { core::arch::asm!("/* {:er}", in(reg) 5i32); }
// 错误: asm 模板修饰符必须是单个字符
```

支持的修饰符是 LLVM(和 GCC)的 asm 模板参数修饰符的子集,但不使用相同的字母代码。

| Architecture | Register class | Modifier | Example output | LLVM modifier |
| ------ | ------ | ------ | ----- | ----- |
| RISC-V | reg | None | x1 | None |
| RISC-V | freg | None | f0 | None |

> Note
>
> + on ARM e / f: this prints the low or high doubleword register name of a NEON quad (128-bit) register.
> + on x86: our behavior for reg with no modifiers differs from what GCC does. GCC will infer the modifier based on the operand value type, while we default to the full register size.
> + on x86 xmm_reg: the x, t and g LLVM modifiers are not yet implemented in LLVM (they are supported by GCC only), but this should be a simple change.

``` rust
let mut x = 0x10u16;

// u16::swap_bytes using `xchg`
// low half of `{x}` is referred to by `{x:l}`, and the high half by `{x:h}`
unsafe { core::arch::asm!("xchg {x:l}, {x:h}", x = inout(reg_abcd) x); }
assert_eq!(x, 0x1000u16);
```

如前一节所述,传递小于寄存器宽度的输入值将导致寄存器的高位包含未定义的值。如果内联汇编仅访问寄存器的低位,这不是问题,可以通过使用模板修饰符在汇编代码中使用子寄存器名称(例如 ax 而不是 rax)来实现。由于这是一个容易出错的地方,编译器会根据输入类型建议使用模板修饰符。如果对操作数的所有引用都已有修饰符,则该操作数的警告将被抑制。

## ABI clobbers

clobber_abi 关键字可用于对汇编代码应用默认的破坏集。这将根据需要自动插入必要的破坏约束,用于调用具有特定调用约定的函数:如果调用约定在调用过程中不完全保留寄存器的值,则会隐式地将 lateout("...") _ 添加到操作数列表中(其中 ... 被寄存器名称替换)。

``` rust
extern "C" fn foo() -> i32 { 0 }

let z: i32;
// To call a function, we have to inform the compiler that we're clobbering
// callee saved registers
unsafe { core::arch::asm!("call {}", sym foo, out("rax") z, clobber_abi("C")); }
assert_eq!(z, 0);
```

`clobber_abi` 可以指定任意次数。它将为所有指定调用约定的并集中的所有唯一寄存器插入破坏。

``` rust
extern "sysv64" fn foo() -> i32 { 0 }
extern "win64" fn bar(x: i32) -> i32 { x + 1}

let z: i32;
// We can even call multiple functions with different conventions and
// different saved registers
unsafe {
    core::arch::asm!(
        "call {}",
        "mov ecx, eax",
        "call {}",
        sym foo,
        sym bar,
        out("rax") z,
        clobber_abi("C")
    );
}
assert_eq!(z, 1);
```

当使用 clobber_abi 时,编译器不允许使用通用寄存器类别输出:所有输出必须指定显式寄存器。

``` rust
extern "C" fn foo(x: i32) -> i32 { 0 }

let z: i32;
// explicit registers must be used to not accidentally overlap.
unsafe {
    core::arch::asm!(
        "mov eax, {:e}",
        "call {}",
        out(reg) z,
        sym foo,
        clobber_abi("C")
    );
    // ERROR: asm with `clobber_abi` must specify explicit registers for outputs
}
assert_eq!(z, 0);
```

显式寄存器输出优先于 clobber_abi 插入的隐式破坏:只有当寄存器未用作输出时,才会为该寄存器插入破坏。

The following ABIs can be used with clobber_abi:

| Architecture | ABI name | Clobbered registers |
| ---------- | -------- | --------- |
| RISC-V | "C", "system", "efiapi" | x1, x[5-7], x[10-17]*, x[28-31]*, f[0-7], f[10-17], f[28-31], v[0-31] |

> Note
> 
> + On AArch64 x18 only included in the clobber list if it is not considered as a reserved register on the target.
> + 在 RISC-V 上,只有当 x[16-17] 和 x[28-31] 在目标上不被视为保留寄存器时,才会包含在破坏列表中。

每个 ABI 的被破坏寄存器列表会在 rustc 中随着架构获得新寄存器而更新:这确保当 LLVM 开始在其生成的代码中使用这些新寄存器时,asm! 破坏将继续是正确的。

## Options

标志用于进一步影响内联汇编代码的行为。当前定义了以下选项:

+ pure: 汇编代码没有副作用,必须最终返回,其输出仅取决于其直接输入(即值本身,而不是它们指向的内容)或从内存读取的值(除非还设置了 nomem 选项)。这允许编译器执行汇编代码的次数少于程序中指定的次数(例如通过将其提升出循环),甚至如果不使用输出则完全消除它。pure 选项必须与 nomem 或 readonly 选项之一结合使用,否则会发出编译时错误。
    ``` rust
    let x: i32 = 0;
    let z: i32;
    // pure can be used to optimize by assuming the assembly has no side effects
    unsafe { core::arch::asm!("inc {}", inout(reg) x => z, options(pure, nomem)); }
    assert_eq!(z, 1);
    ```
    ``` rust
    let x: i32 = 0;
    let z: i32;
    // Either nomem or readonly must be satisfied, to indicate whether or not
    // memory is allowed to be read
    unsafe { core::arch::asm!("inc {}", inout(reg) x => z, options(pure)); }
    // ERROR: the `pure` option must be combined with either `nomem` or `readonly`
    assert_eq!(z, 0);
    ```

+ nomem: 汇编代码不读取或写入汇编代码外部可访问的任何内存。这允许编译器在汇编代码执行期间将修改的全局变量的值缓存在寄存器中,因为它知道汇编代码不会读取或写入它们。编译器还假设汇编代码不执行任何与其他线程的同步,例如通过fences。
    + ✅ 外部内存：全局变量、传入的指针指向的数据、堆分配的内存
    + ❌ 非外部内存：汇编内部临时使用的栈空间、只在汇编内部操作的寄存器
    ``` rust
    let mut x = 0i32;
    let z: i32;
    // 当指定 `nomem` 时,不允许从汇编访问外部内存
    unsafe {
        core::arch::asm!("mov {val:e}, dword ptr [{ptr}]",
            ptr = in(reg) &mut x,
            val = lateout(reg) z,
            options(nomem)
        )
    }

    // 当指定 `nomem` 时,从汇编写入外部内存
    // 也是未定义行为
    unsafe {
        core::arch::asm!("mov  dword ptr [{ptr}], {val:e}",
            ptr = in(reg) &mut x,
            val = in(reg) z,
            options(nomem)
        )
    }
    ```
    ``` rust
    let x: i32 = 0;
    let z: i32;
    // 但是,如果我们分配自己的内存,例如通过 `push`,
    // 我们仍然可以使用它
    unsafe {
        core::arch::asm!("push {x}", "add qword ptr [rsp], 1", "pop {x}",
            x = inout(reg) x => z,
            options(nomem)
        );
    }
    assert_eq!(z, 1);
    assert_eq!(z, 1);
    ```

+ readonly: 汇编代码不写入汇编代码外部可访问的任何内存。这允许编译器在汇编代码执行期间将未修改的全局变量的值缓存在寄存器中,因为它知道汇编代码不会写入它们。编译器还假设此汇编代码不执行任何与其他线程的同步,例如通过fences。
    + 核心概念：可以读内存，但保证不修改。

    ``` rust
    let mut x = 0;
    // We cannot modify outside memory when `readonly` is specified
    unsafe {
        core::arch::asm!("mov dword ptr[{}], 1", in(reg) &mut x, options(readonly))
    }
    let x: i64 = 0;
    let z: i64;
    // We can still read from it, though
    unsafe {
        core::arch::asm!("mov {x}, qword ptr [{x}]",
            x = inout(reg) &x => z,
            options(readonly)
        );
    }
    assert_eq!(z, 0);
    ```

    ``` rust
    let x: i64 = 0;
    let z: i64;
    // Same exception applies as with nomem.
    unsafe {
        core::arch::asm!("push {x}", "add qword ptr [rsp], 1", "pop {x}",
            x = inout(reg) x => z,
            options(readonly)
        );
    }
    assert_eq!(z, 1);
    ```

+ preserves_flags: 汇编代码不修改标志寄存器(在下面的规则中定义)。这允许编译器避免在执行汇编代码后重新计算条件标志.
    + 核心概念：不修改 CPU 的标志寄存器（EFLAGS/RFLAGS）

+ noreturn: 汇编代码不会正常执行完毕;如果执行完毕则行为未定义。它仍然可以跳转到标签块。如果任何标签块返回 unit,asm! 块将返回 unit。否则它将返回 !(never)。与调用不返回的函数一样,在执行汇编代码之前不会丢弃作用域中的局部变量。
    ``` rust
    fn main() -> ! {
        // We can use an instruction to trap execution inside of a noreturn block
        unsafe { core::arch::asm!("ud2", options(noreturn)); }
    }
    ```
    ``` rust
    // You are responsible for not falling past the end of a noreturn asm block
    unsafe { core::arch::asm!("", options(noreturn)); }
    ```
    ``` rust
    let _: () = unsafe {
        // You may still jump to a `label` block
        core::arch::asm!("jmp {}", label {
            println!();
        }, options(noreturn));
    };
    ```

+ nostack: 汇编代码不将数据推送到堆栈,或写入堆栈红区(如果目标支持)。如果不使用此选项,则堆栈指针保证在函数调用之前根据目标 ABI 进行适当对齐。

    ``` rust
    // `push` and `pop` are UB when used with nostack
    unsafe { core::arch::asm!("push rax", "pop rax", options(nostack)); }
    ```

+ att_syntax: 此选项仅在 x86 上有效,导致汇编器使用 GNU 汇编器的 .att_syntax 前缀模式。寄存器操作数将替换为前导 %。
    ``` rust
    let x: i32;
    let y = 1i32;
    // We need to use AT&T Syntax here. src, dest order for operands
    unsafe {
        core::arch::asm!("mov {y:e}, {x:e}",
            x = lateout(reg) x,
            y = in(reg) y,
            options(att_syntax)
        );
    }
    assert_eq!(x, y);
    ```

+ raw: 这会导致模板字符串被解析为原始汇编字符串,对 { 和 } 不进行特殊处理。这主要用于使用 include_str! 包含来自外部文件的原始汇编代码。
The compiler performs some additional checks on options:

+ nomem 和 readonly 选项是互斥的:同时指定两者是编译时错误。
    ``` rust
    // nomem is strictly stronger than readonly, they can't be specified together
    unsafe { core::arch::asm!("", options(nomem, readonly)); }
    // ERROR: the `nomem` and `readonly` options are mutually exclusive
    ```

+ 在没有输出或只有丢弃输出(_)的 asm 块上指定 pure 是编译时错误。
    ``` rust
    // pure blocks need at least one output
    unsafe { core::arch::asm!("", options(pure)); }
    // ERROR: asm with the `pure` option must have at least one output
    ```

+ 在有输出且没有标签的 asm 块上指定 noreturn 是编译时错误。
    ``` rust
    let z: i32;
    // noreturn can't have outputs
    unsafe { core::arch::asm!("mov {:e}, 1", out(reg) z, options(noreturn)); }
    // ERROR: asm outputs are not allowed with the `noreturn` option
    ```

+ 在有输出的 asm 块中包含任何标签块是编译时错误。

naked_asm! 仅支持 att_syntax 和 raw 选项。其余选项没有意义,因为内联汇编定义了整个函数体。
global_asm! 仅支持 att_syntax 和 raw 选项。其余选项对全局作用域内联汇编没有意义。

``` rust
// nomem is useless on global_asm!
core::arch::global_asm!("", options(nomem));
```

## Rules for inline assembly

为避免未定义行为,使用函数作用域内联汇编(asm!)时必须遵循以下规则:

+ 任何未指定为输出的寄存器在退出汇编代码时必须具有与进入时相同的值,否则行为未定义。
    + 这仅适用于可以指定为输入或输出的寄存器。其他寄存器遵循特定于目标的规则。
    + 请注意,lateout 可能被分配到与 in 相同的寄存器,在这种情况下此规则不适用。但代码不应依赖此行为,因为它取决于寄存器分配的结果。
+ 如果执行从汇编代码中展开,则行为未定义。
    + 如果汇编代码调用随后展开的函数,这也适用。
+ 汇编代码允许读取和写入的内存位置集合与 FFI 函数允许的内存位置相同。
    + 如果设置了 readonly 选项,则仅允许内存读取。
    + 如果设置了 nomem 选项,则不允许读取或写入内存。
    + 这些规则不适用于汇编代码私有的内存,例如在其中分配的堆栈空间。
+ 编译器不能假设汇编代码中的指令是实际执行的指令。
    + 这实际上意味着编译器必须将汇编代码视为黑盒,仅考虑接口规范,而不考虑指令本身。
    + 允许运行时代码修补,通过特定于目标的机制。
    + 但是,不能保证源代码中的每个汇编代码块直接对应于目标文件中的单个指令实例;编译器可以自由复制或去重 asm! 块中的汇编代码。
+ 除非设置了 nostack 选项,否则允许汇编代码使用堆栈指针下方的堆栈空间。  
    + 在进入汇编代码时,堆栈指针保证根据目标 ABI 进行适当对齐以进行函数调用。
    + 您有责任确保不会溢出堆栈(例如使用堆栈探测以确保命中保护页)。
    + 您应该根据目标 ABI 的要求在分配堆栈内存时调整堆栈指针。
    + 在离开汇编代码之前,堆栈指针必须恢复到其原始值。
+ 如果设置了 noreturn 选项,则如果执行在汇编代码末尾正常结束,行为未定义。
+ 如果设置了 pure 选项,则如果 asm! 具有除其直接输出之外的副作用,行为未定义。如果使用相同输入的两次 asm! 代码执行产生不同的输出,行为也未定义。
    + 与 nomem 选项一起使用时,"输入"仅是 asm! 的直接输入。
    + 与 readonly 选项一起使用时,"输入"包括汇编代码的直接输入以及允许其读取的任何内存。
+ 如果设置了 preserves_flags 选项,则这些标志寄存器必须在退出汇编代码时恢复:
    + x86
        + EFLAGS 中的状态标志(CF、PF、AF、ZF、SF、OF)。
        + 浮点状态字(全部)。
        + MXCSR 中的浮点异常标志(PE、UE、OE、ZE、DE、IE)。
    + ARM
        + CPSR 中的条件标志(N、Z、C、V)
        + CPSR 中的饱和标志(Q)
        + CPSR 中的大于或等于标志(GE)。
        + FPSCR 中的条件标志(N、Z、C、V)
        + FPSCR 中的饱和标志(QC)
        + FPSCR 中的浮点异常标志(IDC、IXC、UFC、OFC、DZC、IOC)。
        + AArch64 和 Arm64EC
        + 条件标志(NZCV 寄存器)。
        + 浮点状态(FPSR 寄存器)。
    + RISC-V
        + fcsr 中的浮点异常标志(fflags)。
        + 向量扩展状态(vtype、vl、vcsr)。
    + LoongArch
        + Floating-point condition flags in $fcc[0-7].
    + s390x
        + 条件码寄存器 cc。

+ 在 x86 上,方向标志(EFLAGS 中的 DF)在进入汇编代码时被清除,并且在退出时必须被清除。
    + 如果在退出汇编代码时设置了方向标志,则行为未定义。
+ 在 x86 上,x87 浮点寄存器堆栈必须保持不变,除非所有 st([0-7]) 寄存器都已标记为被破坏,使用 out("st(0)") _、out("st(1)") _ 等。
    + 如果所有 x87 寄存器都被破坏,则在进入汇编代码时 x87 寄存器堆栈保证为空。汇编代码必须确保在退出汇编代码时 x87 寄存器堆栈也为空。

``` rust
pub fn fadd(x: f64, y: f64) -> f64 {
  let mut out = 0f64;
  let mut top = 0u16;
  // we can do complex stuff with x87 if we clobber the entire x87 stack
  unsafe { core::arch::asm!(
    "fld qword ptr [{x}]",
    "fld qword ptr [{y}])",
    "faddp",
    "fstp qword ptr [{out}]",
    "xor eax, eax",
    "fstsw ax",
    "shl eax, 11",
    x = in(reg) &x,
    y = in(reg) &y,
    out = in(reg) &mut out,
    out("st(0)") _, out("st(1)") _, out("st(2)") _, out("st(3)") _,
    out("st(4)") _, out("st(5)") _, out("st(6)") _, out("st(7)") _,
    out("eax") top
  );}

  assert_eq!(top & 0x7, 0);
  out
}

pub fn main() {
  assert_eq!(fadd(1.0, 1.0), 2.0);
}
```

+ 在 arm64ec 上,调用带有适当 thunk 的函数时,调用检查器是强制性的。
+ 将堆栈指针和非输出寄存器恢复到其原始值的要求仅在退出汇编代码时适用。
    + 这意味着不会正常结束且不跳转到任何标签块的汇编代码,即使未标记为 noreturn,也不需要保留这些寄存器。
    + 当返回到与您进入的不同 asm! 块的汇编代码时(例如用于上下文切换),这些寄存器必须包含进入您正在退出的 asm! 块时的值。
        + 您不能退出尚未进入的 asm! 块的汇编代码。也不能退出已经退出的 asm! 块的汇编代码(除非先再次进入)。
        + 您有责任切换任何特定于目标的状态(例如线程本地存储、堆栈边界)。
        + 您不能从一个 asm! 块中的地址跳转到另一个 asm! 块中的地址,即使在同一函数或块内,也不能将它们的上下文视为可能不同并需要上下文切换。您不能假设这些上下文中的任何特定值(例如当前堆栈指针或堆栈指针下方的临时值)在两个 asm! 块之间将保持不变。
        + 您可以访问的内存位置集合是您进入和退出的 asm! 块所允许的内存位置的交集。
+ 您不能假设源代码中相邻的两个 asm! 块,即使它们之间没有其他代码,在二进制文件中也会以连续地址出现,它们之间没有其他指令。
+ 您不能假设 asm! 块在输出二进制文件中只出现一次。编译器允许实例化 asm! 块的多个副本,例如当包含它的函数在多个位置内联时。
+ 在 x86 上,内联汇编不能以适用于编译器生成的指令的指令前缀(例如 LOCK)结尾。由于编译内联汇编的方式,编译器目前无法检测到这一点,但将来可能会捕获并拒绝这种情况。
> Note
> 
> As a general rule, the flags covered by preserves_flags are those which are not preserved when performing a function call.

## Rules for naked inline assembly

To avoid undefined behavior, these rules must be followed when using function-scope inline assembly in naked functions (naked_asm!):

+ 根据调用约定和函数签名,任何未用于函数输入的寄存器在进入 naked_asm! 块时将包含未定义的值。
    + 在内联汇编的上下文中,"未定义值"意味着寄存器可以(非确定性地)具有架构允许的任何可能值之一。值得注意的是,它与 LLVM undef 不同,后者每次读取时可以具有不同的值(因为在汇编代码中不存在这样的概念)。
+ 所有被调用者保存的寄存器在返回时必须具有与进入时相同的值。
+ 调用者保存的寄存器可以自由使用。
+ 如果执行在汇编代码末尾正常结束,则行为未定义。
    + 汇编代码中的每条路径都应该以返回指令终止或发散。
+ 汇编代码允许读取和写入的内存位置集合与 FFI 函数允许的内存位置相同。
+ 编译器不能假设 naked_asm! 块中的指令是实际执行的指令。
    + 这实际上意味着编译器必须将 naked_asm! 视为黑盒,仅考虑接口规范,而不考虑指令本身。
    + 允许运行时代码修补,通过特定于目标的机制。
+ 允许从 naked_asm! 块中展开。
    + 为了正确行为,必须使用发出展开元数据的适当汇编器指令。

``` rust
#[unsafe(naked)]
extern "sysv64-unwind" fn unwinding_naked() {
    core::arch::naked_asm!(
        // 这里的 "CFI" 代表 "调用帧信息"。
        ".cfi_startproc",
        // CFA(规范帧地址)是 `call` 之前 `rsp` 的值
        // 即在返回地址 `rip` 被推送到 `rsp` 之前,
        // 因此它在内存中比函数入口时的 `rsp` 高 8 字节
        // (在 `rip` 被推送之后)。
        //
        // 这是默认值,所以我们不必写它。
        //".cfi_def_cfa rsp, 8",
        //
        // 传统的做法是保留基指针,
        // 所以我们会这样做。
        "push rbp",
        // 由于我们现在在内存中将堆栈向下扩展了 8 字节,
        // 我们需要将从 `rsp` 到 CFA 的偏移量再调整 8 字节。
        ".cfi_adjust_cfa_offset 8",
        // 然后我们还要标注我们存储调用者的 `rbp` 值的位置,
        // 相对于 CFA,这样在展开到调用者时我们可以找到它,
        // 以防我们需要它来计算调用者相对于它的 CFA。
        //
        // 这里,我们将调用者的 `rbp` 存储在 CFA 下方 16 字节的位置。
        // 即从 CFA 开始,首先是 `rip`(从 CFA 下方 8 字节开始,
        // 一直到 CFA),然后是我们刚刚推送的调用者的 `rbp`。
        ".cfi_offset rbp, -16",
        // 按照传统,我们将基指针设置为堆栈指针的值。
        // 这样,基指针在整个函数体中保持不变。
        "mov rbp, rsp",
        // 我们现在可以从基指针跟踪到 CFA 的偏移量。
        // 这意味着在结束之前我们不需要做任何进一步的调整,
        // 因为我们不会改变 `rbp`。
        ".cfi_def_cfa_register rbp",
        // 我们现在可以调用可能 panic 的函数。
        "call {f}",
        // 返回时,我们恢复 `rbp` 以准备返回。
        "pop rbp",
        // 现在我们已经恢复了 `rbp`,我们必须再次
        // 根据 `rsp` 指定到 CFA 的偏移量。
        ".cfi_def_cfa rsp, 8",
        // 现在我们可以返回了。
        "ret",
        ".cfi_endproc",
        f = sym may_panic,
    )
}

extern "sysv64-unwind" fn may_panic() {
    panic!("unwind");
}
```

> Note
> 
> For more information on the cfi assembler directives above, see these resources:
> + [Using as - CFI directives](https://sourceware.org/binutils/docs/as/CFI-directives.html)
> + [DWARF Debugging Information Format Version 5](https://dwarfstd.org/doc/DWARF5.pdf)
> + [ImperialViolet - CFI directives in assembly files](https://www.imperialviolet.org/2017/01/18/cfi.html)

### 正确性和有效性

除了所有先前的规则之外,asm! 的字符串参数最终必须成为——在所有其他参数被求值、执行格式化并翻译操作数之后——对于目标架构在语法上正确且语义上有效的汇编。格式化规则允许编译器生成具有正确语法的汇编。关于操作数的规则允许将 Rust 操作数有效地翻译到汇编代码中和从汇编代码中翻译出来。遵守这些规则是必要的,但对于最终扩展的汇编既正确又有效还不够充分。例如:

+ 参数可能被放置在格式化后语法不正确的位置
+ 指令可能被正确编写,但给出了架构上无效的操作数
+ 架构上未指定的指令可能被汇编成未指定的代码
+ 一组指令,每个都正确且有效,但如果紧接连续放置可能会导致未定义行为

因此,这些规则并不详尽。编译器不需要检查初始字符串或生成的最终汇编的正确性和有效性。汇编器可能会检查正确性和有效性,但不是必须这样做。使用 asm! 时,排版错误可能足以使程序不健全,汇编规则可能包括数千页的架构参考手册。程序员应该格外小心,因为调用此不安全功能伴随着承担不违反编译器或架构规则的责任。

### 指令支持

内联汇编支持 GNU AS 和 LLVM 内部汇编器支持的指令的子集,如下所示。使用其他指令的结果是汇编器特定的(可能导致错误,或可能按原样接受)。

如果内联汇编包含任何修改后续汇编处理方式的"有状态"指令,则汇编代码必须在内联汇编结束之前撤消任何此类指令的效果。

以下指令保证由汇编器支持:

+ `.2byte`
+ `.4byte`
+ `.8byte`
+ `.align`
+ `.alt_entry`
+ `.ascii`
+ `.asciz`
+ `.balign`
+ `.balignl`
+ `.balignw`
+ `.bss`
+ `.byte`
+ `.comm`
+ `.data`
+ `.def`
+ `.double`
+ `.endef`
+ `.equ`
+ `.equiv`
+ `.eqv`
+ `.fill`
+ `.float`
+ `.global`
+ `.globl`
+ `.inst`
+ `.insn`
+ `.lcomm`
+ `.long`
+ `.octa`
+ `.option`
+ `.p2align`
+ `.popsection`
+ `.private_extern`
+ `.pushsection`
+ `.quad`
+ `.scl`
+ `.section`
+ `.set`
+ `.short`
+ `.size`
+ `.skip`
+ `.sleb128`
+ `.space`
+ `.string`
+ `.text`
+ `.type`
+ `.uleb128`
+ `.word`

``` rust
let bytes: *const u8;
let len: usize;
unsafe {
    core::arch::asm!(
        "jmp 3f", "2: .ascii \"Hello World!\"",
        "3: lea {bytes}, [2b+rip]",
        "mov {len}, 12",
        bytes = out(reg) bytes,
        len = out(reg) len
    );
}

let s = unsafe { core::str::from_utf8_unchecked(core::slice::from_raw_parts(bytes, len)) };

assert_eq!(s, "Hello World!");
```
